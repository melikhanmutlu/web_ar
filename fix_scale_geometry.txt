Fix: Apply Scale to Geometry (Permanent) + Fix Color Loading

Critical Fixes:

1. Scale Now Applied to Actual Geometry
   Problem: Scale was applied as node transform, not permanent
   - GLB saved with scale transform
   - But AR viewers ignored node transforms
   - Model always appeared at original size
   - Dimensions didn't actually change

   Solution: Scale vertices directly
   - Modify mesh vertex positions
   - Permanent geometry change
   - Works in all AR viewers
   - Actual dimensions change

2. Color Loading Fixed
   Problem: Material color loaded multiple times, causing white
   - Event listener fired multiple times
   - Last load might be default white
   - Sidebar showed white even when model had color

   Solution: Load once with flag
   - materialPropertiesLoaded flag
   - Prevent multiple loads
   - Consistent color display

Implementation:

1. Geometry Scaling (glb_modifier.py):

Before:
```python
# Applied to node transform (temporary)
node.scale = [scale_factor, scale_factor, scale_factor]
```

After:
```python
# Apply to mesh vertices (permanent)
for mesh in gltf.meshes:
    for primitive in mesh.primitives:
        # Get POSITION accessor
        accessor = gltf.accessors[primitive.attributes.POSITION]
        buffer_view = gltf.bufferViews[accessor.bufferView]
        buffer = gltf.buffers[buffer_view.buffer]
        
        # Decode binary data
        binary_data = base64.b64decode(buffer.uri)
        
        # Scale each vertex
        for i in range(vertex_count):
            x, y, z = struct.unpack_from('fff', binary_data, pos)
            x *= scale_factor
            y *= scale_factor
            z *= scale_factor
            struct.pack_into('fff', new_data, pos, x, y, z)
        
        # Update buffer
        buffer.uri = 'data:...' + base64.b64encode(new_data)
```

How It Works:

1. Read vertex positions from GLB buffer
2. Decode base64 binary data
3. Parse float triplets (X, Y, Z)
4. Multiply each coordinate by scale_factor
5. Write back to buffer
6. Re-encode as base64
7. Update GLB buffer URI

Result: Permanent geometry change

2. Color Loading Fix (view.html):

Before:
```javascript
modelViewer.addEventListener('load', () => {
    scene.traverse((child) => {
        if (child.isMesh) {
            const hex = mat.color.getHexString();
            materialColor.value = hex;
            return; // Only exits traverse, not listener!
        }
    });
});
```

After:
```javascript
let materialPropertiesLoaded = false;
modelViewer.addEventListener('load', () => {
    if (materialPropertiesLoaded) return; // Prevent multiple loads
    
    let foundMaterial = false;
    scene.traverse((child) => {
        if (!foundMaterial && child.isMesh) {
            const hex = mat.color.getHexString();
            materialColor.value = hex;
            foundMaterial = true;
            materialPropertiesLoaded = true;
        }
    });
});
```

Test Cases:

Test 1: Scale to 2x
```
1. Original model: 50cm
2. Set scale: 2.0x
3. Save & Apply to AR
4. Backend: Scales all vertices by 2.0
5. New geometry: 100cm (actual)
6. View in AR: 100cm ✅
7. Dimension display: 100cm ✅
```

Test 2: Scale to 0.5x
```
1. Original model: 100cm
2. Set scale: 0.5x
3. Save & Apply to AR
4. Backend: Scales all vertices by 0.5
5. New geometry: 50cm (actual)
6. View in AR: 50cm ✅
7. Dimension display: 50cm ✅
```

Test 3: Multiple Scales
```
Save 1: scale=2.0 → Model becomes 100cm
Save 2: scale=1.5 → Model becomes 150cm (100 * 1.5)
Save 3: scale=0.5 → Model becomes 75cm (150 * 0.5)
```

Test 4: Color Persistence
```
1. Set color: #ff0000 (red)
2. Save & Apply to AR
3. Page reload
4. Sidebar shows: #ff0000 ✅
5. Model shows: Red ✅
6. Console: "Loaded material color: #ff0000" ✅
```

Technical Details:

GLB Buffer Structure:
```
Buffer (base64 encoded binary)
  ↓
BufferView (slice of buffer)
  ↓
Accessor (typed view of buffer view)
  ↓
Primitive.attributes.POSITION (vertex positions)
```

Vertex Scaling Process:
```
1. Get accessor index from primitive.attributes.POSITION
2. Get accessor from gltf.accessors[index]
3. Get bufferView from gltf.bufferViews[accessor.bufferView]
4. Get buffer from gltf.buffers[bufferView.buffer]
5. Decode base64 URI to binary
6. Calculate offset: bufferView.byteOffset + accessor.byteOffset
7. For each vertex (accessor.count):
   - Read 3 floats (X, Y, Z) at offset + i * stride
   - Multiply by scale_factor
   - Write back 3 floats
8. Encode binary to base64
9. Update buffer.uri
```

Stride Calculation:
```
stride = bufferView.byteStride || 12
// 12 bytes = 3 floats * 4 bytes per float
```

Benefits:

Scale to Geometry:
✅ Permanent size change
✅ Works in all AR viewers
✅ Actual dimensions change
✅ No transform tricks
✅ Clean GLB structure

Color Loading:
✅ Loads once
✅ Consistent display
✅ No white flicker
✅ Reliable state

Limitations:

Scale Slider:
- Always starts at 1.0 after save
- Because scale is baked into geometry
- Slider represents "next scale to apply"
- Not "current scale of model"

Workaround:
- Dimension display shows actual size
- User sees real measurements
- Scale slider is for next modification

Example Workflow:
```
1. Upload 50cm model
2. Dimensions: 50cm
3. Scale slider: 1.0x
4. Set slider: 2.0x
5. Save
6. Dimensions: 100cm ✅
7. Scale slider: 1.0x (reset for next modification)
8. Set slider: 1.5x
9. Save
10. Dimensions: 150cm (100 * 1.5) ✅
```

Result:
Scale now permanently modifies model geometry, making size changes visible in all AR viewers. Color loading is fixed to prevent white color issues.
