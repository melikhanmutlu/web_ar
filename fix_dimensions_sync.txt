Fix: Dimension Synchronization & Scale Input

Critical Fixes:

1. Dimension Mismatch Between Info Modal and Transform Panel
   Problem: Two different dimension sources showing different values
   - Info Modal: 56.22 x 79.52 x 51.26 cm (from database)
   - Transform Panel: 7.1 x 6.5 x 10.1 cm (from GLB)
   - ❌ Completely different!

   Root Cause:
   - Database dimensions saved at upload (original size)
   - get_model_dimensions reads current GLB (scaled size)
   - After scale, database not updated
   - Two sources out of sync

   Solution:
   - Update database dimensions after save_modifications
   - Both sources now read same GLB file
   - Always in sync

2. Database Not Updated After Scale
   Problem: Scale applied but database still shows old dimensions
   
   Before:
   ```python
   # save_modifications
   shutil.move(temp_output, original_path)
   return jsonify({'success': True})
   # ❌ Database not updated!
   ```

   After:
   ```python
   # save_modifications
   shutil.move(temp_output, original_path)
   
   # Update database dimensions
   mesh = trimesh.load(original_path)
   dimensions = mesh.bounds[1] - mesh.bounds[0]
   new_dims = {
       'x': round(float(dimensions[0] * 100), 2),
       'y': round(float(dimensions[1] * 100), 2),
       'z': round(float(dimensions[2] * 100), 2),
       'max': round(float(max(dimensions) * 100), 2)
   }
   
   model = UserModel.query.filter_by(filename=f'converted/{model_id}/model.glb').first()
   model.dimensions = new_dims
   db.session.commit()
   
   return jsonify({'success': True})
   ```

3. Scale Input Field Added
   Problem: Only slider available, no manual input
   User Request: Add input field for precise values

   Solution:
   ```html
   <!-- Before: Only slider -->
   <input type="range" id="scaleSlider" min="0.1" max="10" step="0.1">
   <span id="scaleValue">1.0x</span>

   <!-- After: Slider + Input -->
   <input type="range" id="scaleSlider" min="0.1" max="10" step="0.1">
   <input type="number" id="scaleInput" min="0.1" max="10" step="0.1">
   ```

4. Live Preview Improved
   Problem: Slider and input not synchronized
   
   Solution:
   ```javascript
   function updateScale(value) {
       value = Math.max(0.1, Math.min(10, parseFloat(value)));
       scaleSlider.value = value;
       scaleInput.value = value.toFixed(1);
       modelViewer.scale = `${value} ${value} ${value}`;
       updateDimensionDisplay(value);
   }
   
   scaleSlider.addEventListener('input', (e) => {
       updateScale(e.target.value);
   });
   
   scaleInput.addEventListener('input', (e) => {
       updateScale(e.target.value);
   });
   ```

How It Works Now:

1. Upload Model:
```
1. User uploads 200cm model
2. Conversion completes
3. Database saves: 200cm
4. get_model_dimensions reads GLB: 200cm
5. Info Modal: 200cm ✅
6. Transform Panel: 200cm ✅
```

2. Scale Model:
```
1. User sets scale: 2.0x
2. Save & Apply to AR
3. Backend:
   - Scales vertices by 2.0
   - Saves GLB
   - Reads new dimensions: 400cm
   - Updates database: 400cm ✅
4. Page reload
5. Info Modal: 400cm ✅
6. Transform Panel: 400cm ✅
```

3. Manual Scale Input:
```
1. User types in input: 3.5
2. Slider updates to 3.5 ✅
3. Model scales to 3.5x ✅
4. Dimensions update: 3.5x original ✅
```

4. Slider Scale:
```
1. User drags slider to 2.5
2. Input updates to 2.5 ✅
3. Model scales to 2.5x ✅
4. Dimensions update: 2.5x original ✅
```

Test Cases:

Test 1: Upload and Check Dimensions
```
Upload: 100cm model
Info Modal: 100cm ✅
Transform Panel: 100cm ✅
get_model_dimensions: 100cm ✅
Database: 100cm ✅
```

Test 2: Scale and Check Sync
```
Original: 50cm
Scale: 3.0x
Save
Info Modal: 150cm ✅
Transform Panel: 150cm ✅
get_model_dimensions: 150cm ✅
Database: 150cm ✅
```

Test 3: Multiple Scales
```
Original: 100cm
Scale 2x: 200cm
  - Info Modal: 200cm ✅
  - Transform: 200cm ✅
Scale 0.5x: 100cm
  - Info Modal: 100cm ✅
  - Transform: 100cm ✅
```

Test 4: Manual Input
```
Type: 4.7
Slider: 4.7 ✅
Model: 4.7x ✅
Dimensions: 4.7x original ✅
```

Test 5: Slider Drag
```
Drag to: 6.3
Input: 6.3 ✅
Model: 6.3x ✅
Dimensions: 6.3x original ✅
```

Test 6: Out of Range Input
```
Type: 15 (> max)
Blur: Clamps to 10 ✅
Slider: 10 ✅
Model: 10x ✅
```

Dimension Flow:

Upload:
```
1. Model converted
2. trimesh.load(glb)
3. Calculate dimensions
4. Save to database
5. ✅ Database has original dimensions
```

View Page Load:
```
1. Read database dimensions
2. Display in Info Modal
3. Call get_model_dimensions
4. Display in Transform Panel
5. ✅ Both show same values
```

After Scale:
```
1. Scale vertices
2. Save GLB
3. trimesh.load(glb)
4. Calculate new dimensions
5. Update database
6. ✅ Database has scaled dimensions
```

Next Page Load:
```
1. Read database (scaled dimensions)
2. Display in Info Modal
3. Call get_model_dimensions (reads scaled GLB)
4. Display in Transform Panel
5. ✅ Both show scaled values
```

Benefits:

Dimension Sync:
✅ Info Modal and Transform Panel always match
✅ Database updated after scale
✅ No more conflicting values
✅ Single source of truth (GLB file)

Scale Input:
✅ Manual value entry
✅ Precise control
✅ Slider + Input synchronized
✅ Live preview
✅ Range validation (0.1 - 10)

User Experience:
✅ Clear dimension display
✅ Consistent values everywhere
✅ Multiple input methods
✅ Real-time feedback
✅ No confusion

Technical Details:

Database Update:
```python
# After save_modifications
mesh = trimesh.load(original_path, force='scene')
bounds = mesh.bounds
dimensions = bounds[1] - bounds[0]

new_dims = {
    'x': round(float(dimensions[0] * 100), 2),
    'y': round(float(dimensions[1] * 100), 2),
    'z': round(float(dimensions[2] * 100), 2),
    'max': round(float(max(dimensions) * 100), 2)
}

model.dimensions = new_dims
db.session.commit()
```

Scale Synchronization:
```javascript
function updateScale(value) {
    // Clamp value
    value = Math.max(0.1, Math.min(10, parseFloat(value)));
    
    // Update both controls
    scaleSlider.value = value;
    scaleInput.value = value.toFixed(1);
    
    // Apply to model
    modelViewer.scale = `${value} ${value} ${value}`;
    
    // Update dimension display
    updateDimensionDisplay(value);
}
```

Result:
Dimensions are now synchronized across all displays. Database is updated after scale operations. Scale can be controlled via slider or manual input with live preview.
